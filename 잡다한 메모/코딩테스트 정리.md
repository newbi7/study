Character.isLowerCase(c)
Character.isLowerCase(c) 는 주어진 문자 c 가 소문자인지 확인하는 메서드입니다. 만약 c 가 소문자이면 true 를 반환하고, 그렇지 않으면 false 를 반환합니다.
Character.toUpperCase(c)
Character.toUpperCase(c) 는 주어진 문자 c 를 대문자로 변환하는 메서드입니다.

Arrays.sort(numbers); // 배열을 오름차순으로 정렬
int len = numbers.length;
int max = numbers[len-1] * numbers[len-2]; // 가장 큰 수와 그 이전의 수를 선택하여 곱함
int min = numbers[0] * numbers[1]; // 가장 작은 음수와 그 이전의 수를 선택하여 곱함
return Math.max(max, min); // 두 값 중에서 큰 값을 선택하여 반환


```java

정수가 담긴 배열 numbers와 문자열 direction가 매개변수로 주어집니다. 배열 numbers의 원소를 direction방향으로 한 칸씩 회전시킨 배열을 return하도록 solution 함수를 완성해주세요.

class Solution {
    public int[] solution(int[] numbers, String direction) {
        int n = numbers.length;
        int[] answer = new int[n];
        for (int i = 0; i < n; i++) {
            int index = (direction.equals("left")) ? (i + n - 1) % n : (i + 1) % n;
            answer[index] = numbers[i]; 
        }
        return answer;
    }
}
위 코드는 주어진 숫자 배열을 주어진 방향 (left 또는 right)으로 회전시키는 함수입니다. 함수의 이름은 "solution"이며, 매개변수로 숫자 배열(numbers)과 문자열(direction)을 받습니다.

코드를 자세히 살펴보면, 먼저 숫자 배열의 길이를 구하고, 길이와 같은 크기의 새로운 배열 answer를 생성합니다. 이 배열은 회전시킨 숫자를 저장하기 위한 배열입니다.

그 다음, for 루프를 돌면서 배열의 각 요소에 대해 회전시킨 후의 인덱스를 계산합니다. 이를 위해, 우선 주어진 방향이 "left"인지 "right"인지에 따라 회전할 방향을 결정합니다. "left"인 경우, 현재 인덱스(i)에서 n을 더하고 1을 뺀 값에 n을 나눈 나머지를 구합니다. "right"인 경우에는 현재 인덱스(i)에서 1을 더하고 n으로 나눈 나머지를 구합니다. 이렇게 구한 인덱스 값을 배열 answer의 해당 인덱스 위치에 현재 요소(numbers[i])를 저장합니다.

for 루프가 끝나면, 회전된 숫자 배열이 저장된 배열 answer를 반환합니다.

예를 들어, 주어진 숫자 배열이 [1, 2, 3, 4, 5]이고, 회전 방향이 "left"인 경우, 함수는 [5, 1, 2, 3, 4]를 반환합니다. 회전 방향이 "right"인 경우, 함수는 [2, 3, 4, 5, 1]를 반환합니다.
```

forDigit는 Character 클래스에 정의된 메소드 중 하나입니다. 이 메소드는 정수값(0~35)을 받아 해당 값을 지닌 문자를 반환합니다.
예를 들어, Character.forDigit(0, 10)은 문자열 "0123456789"에서 0번째 문자인 '0'을 반환하고, Character.forDigit(11, 16)은 11을 16진수로 표현한 문자인 'b'를 반환합니다.
주로 forDigit 메소드는 10진수 숫자를 특정 진법의 문자열로 변환할 때 사용됩니다. 예를 들어, Character.forDigit(13, 16)는 13을 16진수로 변환한 문자열 "d"를 반환합니다.


```java
import java.util.HashSet;

class Solution {
    public String solution(String my_string) {
        HashSet<Character> set = new HashSet<>();
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < my_string.length(); i++) {
            char c = my_string.charAt(i);
            if (!set.contains(c)) {
                set.add(c);
                sb.append(c);
            } else {
                int lastIndex = sb.lastIndexOf(Character.toString(c), sb.length()-1);
                if (lastIndex >= 0 && sb.charAt(lastIndex) != c) {
                    sb.deleteCharAt(lastIndex);
                }
            }
        }
        
        return sb.toString();
    }
}
/////////////////////////// 설명
if (!set.contains(c)) {
    set.add(c);
    sb.append(c);
}
만약 HashSet에 해당 문자가 없다면, set.add(c)를 호출해 해당 문자를 HashSet에 추가하고, sb.append(c)를 호출해 해당 문자를 StringBuilder에 추가합니다.

else {
    int lastIndex = sb.lastIndexOf(Character.toString(c), sb.length()-1);
    if (lastIndex >= 0 && sb.charAt(lastIndex) != c) {
        sb.deleteCharAt(lastIndex);
    }
}
그렇지 않은 경우(HashSet에 해당 문자가 있다면)에는, StringBuilder에 이미 추가된 문자열 중에서 마지막으로 등장한 위치를 찾습니다. lastIndexOf 메서드는 지정된 문자 또는 문자열이 마지막으로 등장한 위치를 반환합니다. lastIndex 변수에는 sb.lastIndexOf(Character.toString(c), sb.length()-1)의 결과가 저장됩니다. 이때 sb.length()-1은 탐색을 시작할 위치를 의미합니다.

그 다음, lastIndex가 0 이상이고, StringBuilder에서 찾은 문자가 현재 처리 중인 문자와 다른 경우(sb.charAt(lastIndex) != c)에는 StringBuilder에서 해당 문자를 삭제합니다(sb.deleteCharAt(lastIndex)).

return sb.toString();

모든 문자를 처리한 뒤, StringBuilder에 저장된 문자열을 문자열 형태로 반환합니다.
```

for 문에서 2씩 증가는 c+=2

```java
정수 배열 array와 정수 n이 매개변수로 주어질 때, array에 들어있는 정수 중 n과 가장 가까운 수를 return 하도록 solution 함수를 완성해주세요.

class Solution {
    public int solution(int[] array, int n) {
        int answer = 0;
        int minDiff = Integer.MAX_VALUE;
        for (int i = 0; i < array.length; i++) {
            int diff = Math.abs(array[i] - n);
            if (diff < minDiff) {
                minDiff = diff;
                answer = array[i];
            } else if (diff == minDiff) {
                answer = Math.min(answer, array[i]);
            }
        }
        return answer;
    }
}
```
```java
for (int i = 0; i < array.length; i++) {
    int diff = Math.abs(array[i] - n);
for 반복문을 이용해 배열 array의 각 요소와 n의 차이를 계산합니다. Math.abs() 메서드는 주어진 정수의 절댓값을 반환합니다.


if (diff < minDiff) {
    minDiff = diff;
    answer = array[i];
} else if (diff == minDiff) {
    answer = Math.min(answer, array[i]);
}
diff가 minDiff보다 작은 경우(diff < minDiff)에는 minDiff와 answer를 현재 값으로 갱신합니다.

그렇지 않은 경우(diff >= minDiff)에는 diff와 minDiff가 같은 경우(diff == minDiff)와 다른 경우(diff > minDiff)로 나눠서 처리합니다.

diff와 minDiff가 같은 경우: answer값은 두 수 중 작은 값을 선택합니다. Math.min() 메서드를 사용합니다.
diff와 minDiff가 다른 경우: answer값은 변하지 않습니다.

return answer;
}
모든 요소의 처리가 끝나면, answer값을 반환합니다. 이 값은 n과 가장 차이가 작은 값입니다.
```

```java
외과의사 머쓱이는 응급실에 온 환자의 응급도를 기준으로 진료 순서를 정하려고 합니다. 정수 배열 emergency가 매개변수로 주어질 때 응급도가 높은 순서대로 진료 순서를 정한 배열을 return하도록 solution 함수를 완성해주세요.

입출력 예
emergency	result
[3, 76, 24]	[3, 1, 2]
[1, 2, 3, 4, 5, 6, 7]	[7, 6, 5, 4, 3, 2, 1]
[30, 10, 23, 6, 100]	[2, 4, 3, 5, 1]

import java.util.Arrays;

class Solution {
    public int[] solution(int[] emergency) {
        int[] answer = new int[emergency.length];
        int[] copy = emergency.clone();
        Arrays.sort(copy);
        for(int i=0; i<emergency.length; i++){
            int idx = Arrays.binarySearch(copy, emergency[i]);
            answer[i] = emergency.length - idx;
        }
        return answer;
    }
}
```

```java
개선된 for 문
 

조건

1.JDK 1.5 이상

2.사용할 변수는 지역변수로 인식된다. (For문 안에서 사용되기 때문)
3. 대상은 배열 or 여러 원소를 포함한 자료형이어야 한다.

장점

1.간편한,가독성 좋은 코드
2. 배열 인덱스 문제 해결 (ArrayIndexOutOfBoundsException 예외를 피할 수 있다.)

단점

1.인덱스를 사용하지 못한다.(일반 for문의 (int i=0;) 할 때 i 같은 인덱스를 말하는 것) 하지만 방법이 있다.
★ 중요 ★
2.배열이나 ArrayList 값을 사용할 순 있지만 절대 수정할 수는 없다.

자주 사용되는 상황

1.ArrayList 원소 출력
2.배열 원소 출력

문법
for(자료형 변수명 : 배열명){
	문장
}
 
쉽게 설명하면
for(자료형 한 단계 아래의 자료형의 변수명 : 배열명){
}
정확히 말하면 아래의 자료형이 아니지만 이렇게 생각하면 이해가 쉽더라고요.

실전 예제 - 일반 배열 원소 추출
String[] arr = {"1-1","1-2","1-3","1-4","1-5"};
for(String s : arr) {
 System.out.println(s);
}

//결과 -> 1-1, 1-2, 1-3, 1-4, 1-5
```

.toCharArray(); -> 문자열을 char배열로 변경

```java
StringBuilder

StringBuilder는 Java에서 문자열을 조작하고 관리하는 클래스 중 하나입니다. 문자열을 조작하는 경우 String 클래스를 사용하면 메모리 상의 새로운 문자열 객체가 생성되기 때문에, 문자열 조작이 빈번하게 일어나는 경우에는 String 클래스를 사용하는 것이 효율적이지 않습니다. 이 때문에 StringBuilder 클래스를 사용하여 문자열을 조작하면, 메모리 공간을 효율적으로 사용할 수 있습니다.

StringBuilder 클래스는 가변적인 크기의 문자열을 처리할 수 있으며, 내부적으로 버퍼를 사용하여 문자열을 저장합니다. 이 때문에 문자열 조작이 빠르고 효율적으로 이루어집니다.

StringBuilder 클래스는 String 클래스와 유사한 메서드를 제공합니다. 예를 들어, 문자열 추가, 삭제, 삽입, 변경 등의 작업을 수행할 수 있습니다. 이 때문에 문자열 조작을 할 때, StringBuilder 클래스를 사용하면 성능적인 이점을 얻을 수 있습니다.

아래는 StringBuilder 클래스를 사용하여 문자열을 조작하는 예시입니다.


StringBuilder sb = new StringBuilder();
sb.append("Hello");  // 문자열 추가
sb.append(" ");
sb.append("World!");
sb.insert(6, "Java "); // 6번째 인덱스에 문자열 삽입
sb.delete(5, 6);  // 5번째부터 6번째 전까지 문자열 삭제
sb.replace(5, 10, "C++"); // 5번째부터 10번째 전까지 문자열을 C++로 변경
String result = sb.toString(); // StringBuilder를 String으로 변환
System.out.println(result); // "Java World!"
```

```java
벡터는 크기와 방향을 가진 양으로, 벡터 간의 연산에는 내적과 외적이 있습니다.

내적(dot product)은 두 벡터의 크기와 사이각을 이용하여 스칼라 값을 계산하는 연산입니다. 내적은 다음과 같이 정의됩니다.

a · b = |a||b|cos(θ)

여기서 a와 b는 두 벡터이고, θ는 두 벡터 사이의 각도입니다. 내적의 결과는 스칼라 값입니다.

외적(cross product)은 두 벡터로 만들어지는 평면 벡터를 계산하는 연산입니다. 외적은 다음과 같이 정의됩니다.

a x b = |a||b|sin(θ)n

여기서 a와 b는 두 벡터이고, θ는 두 벡터 사이의 각도입니다. n은 a와 b가 만드는 평면의 법선 벡터입니다. 외적의 결과는 벡터 값입니다.

내적은 두 벡터가 얼마나 비슷한 방향을 가지고 있는지를 나타내는 스칼라 값으로 활용되고, 외적은 두 벡터가 만드는 평면의 법선 벡터를 구할 때 사용됩니다. 또한, 내적과 외적은 물리학, 수학, 그래픽 등에서 다양하게 활용됩니다.

내적과 외적은 벡터의 곱으로서, 다양한 물리학, 수학, 공학 등의 분야에서 사용됩니다. 각각의 의미와 사용 예시는 아래와 같습니다.

내적 (Dot Product)
내적은 두 벡터 사이의 코사인 각도와 벡터의 크기를 곱한 값으로, 스칼라 값을 반환합니다. 내적의 응용 분야로는 다음과 같은 것들이 있습니다.

두 벡터의 사잇각을 구할 수 있습니다.
벡터의 크기를 구할 수 있습니다.
벡터의 투영성분을 구할 수 있습니다.
벡터의 유사도를 측정할 수 있습니다.
외적 (Cross Product)
외적은 두 벡터 사이의 직각삼각형 면적과 벡터의 크기를 곱한 값으로, 벡터 값 자체를 반환합니다. 외적의 응용 분야로는 다음과 같은 것들이 있습니다.

두 벡터로부터 만들어지는 평면의 법선 벡터를 구할 수 있습니다.
물리학에서는 자기장, 토크 등을 구할 때 사용됩니다.
3차원 공간에서의 회전, 운동 등의 계산에 사용됩니다.
내적과 외적은 벡터의 곱으로서, 벡터의 특성을 이용한 다양한 계산에 사용됩니다. 따라서 물리학, 수학, 공학 등의 다양한 분야에서 사용되며, 실제로 많은 문제 해결에 도움이 됩니다.
```
```java
getOrDefault
entrySet
getValue
getKey
groupingBy
getOrDefault(): getOrDefault(Object key, V defaultValue) 메소드는 맵에서 주어진 키가 맵에 존재하면 해당 값을 반환하고, 그렇지 않으면 기본값을 반환합니다.

entrySet(): entrySet() 메소드는 맵에 저장된 키-값 쌍을 Map.Entry 객체로 묶은 Set 컬렉션을 반환합니다.

getValue(): getValue() 메소드는 Map.Entry 객체에서 해당 키에 연관된 값을 반환합니다.

getKey(): getKey() 메소드는 Map.Entry 객체에서 해당 키를 반환합니다.

groupingBy(): groupingBy(Function<? super T,? extends K> classifier) 메소드는 주어진 함수에 따라 요소들을 그룹화하고, 그룹화된 결과를 Map<K, List<T>> 형태로 반환합니다. 이 메소드는 자바 8의 스트림 API에서 사용되는 메소드 중 하나입니다.
```

```java
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

class Solution {
    public String solution(String s) {
        return Arrays.stream(s.split(""))
                .collect(Collectors.groupingBy(s1 -> s1))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue().size() <= 1)
                .map(Map.Entry::getKey)
                .sorted()
                .collect(Collectors.joining());
    }
}

문자열 s를 split 메소드를 이용해 각각의 문자로 분리한 후, Arrays.stream 메소드를 이용해 스트림으로 변환합니다.

Collectors.groupingBy 메소드를 이용해 문자들을 그룹화합니다. 이때, 그룹화의 기준이 되는 키는 문자열 s1 자체입니다.

entrySet 메소드를 이용해 그룹화된 문자열들을 Entry 형태로 스트림으로 변환합니다.

filter 메소드를 이용해 해당 Entry의 value 크기가 1 이하인 것만 걸러냅니다. 이는 중복되지 않은 문자들만 남기기 위함입니다.

map 메소드를 이용해 Entry에서 key 값을 추출합니다.

sorted 메소드를 이용해 문자들을 오름차순으로 정렬합니다.

Collectors.joining 메소드를 이용해 문자열을 하나의 문자열로 합쳐 반환합니다. 이때, 구분자로 아무것도 지정하지 않았기 때문에 연속된 문자열들이 붙어서 반환됩니다.
```

```java

Java 8부터 지원하는 메소드 참조(method reference)를 나타내는 연산자입니다. 메소드 참조는 람다식을 더 간결하게 작성할 수 있도록 도와주는 기능으로, 기존에 존재하는 메소드를 람다식으로 대체할 수 있습니다.

:: 연산자는 두 가지 방법으로 사용됩니다.

정적 메소드 참조
기존에 존재하는 정적 메소드를 참조할 때 사용됩니다. 문법은 클래스명::메소드명 형태입니다.

예를 들어, 다음과 같은 람다식이 있다고 가정해보겠습니다.


(x, y) -> Math.max(x, y)
이 람다식은 두 개의 정수 중 큰 값을 반환하는 람다식입니다. 이를 메소드 참조로 바꾸면 다음과 같이 작성할 수 있습니다.


Math::max
인스턴스 메소드 참조
특정 객체의 인스턴스 메소드를 참조할 때 사용됩니다. 문법은 객체명::메소드명 형태입니다.

예를 들어, 다음과 같은 람다식이 있다고 가정해보겠습니다.


(str) -> str.length()
이 람다식은 문자열의 길이를 반환하는 람다식입니다. 이를 메소드 참조로 바꾸면 다음과 같이 작성할 수 있습니다.


String::length
:: 연산자는 이 외에도 생성자 참조, 배열 생성자 참조 등 다양한 용도로 사용됩니다.

StringBuilder 사용시
-> String 으로 반환해주기 위해서 toString(); 을 쓴다.
```
double -> int로 바꿔주기 (반올림)
        answer = (int) Math.round(flo);
double -> int로 바꿔주기 (버림)
        answer = (int) flo;

```java
substring??
       return my_string.substring(my_string.length() - n);
       substring은 문자열에서 일부 문자열을 추출하는 메서드입니다. substring(startIndex)은 startIndex 인덱스부터 문자열의 끝까지의 부분문자열을 반환하며, substring(startIndex, endIndex)은 startIndex 인덱스부터 endIndex 바로 전 인덱스까지의 부분문자열을 반환합니다.

예를 들어, "hello world".substring(0, 5)는 "hello"를 반환하며, "hello world".substring(6)은 "world"를 반환합니다. 따라서, solution 함수에서 my_string.substring(0, n)은 my_string의 0번 인덱스부터 n-1번 인덱스까지의 부분문자열을 반환합니다.
```


```java
class Solution {
    public int solution(String num_str) {
        int answer = 0;
        String[] num_arr = num_str.split("");
        for (String num : num_arr) {
            answer += Integer.parseInt(num);
        }
        return answer;
}
}
```
```java

단어가 공백 한 개로 구분되어 있는 문자열 my_string이 매개변수로 주어질 때, my_string에 나온 단어를 앞에서부터 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요.
public static String[] solution(String my_string) {
    String[] answer = my_string.split(" "); // 문자열을 공백을 기준으로 분할하여 배열에 저장
    return answer;
}

```

```java
boolean
		if( flag ){
        }
```

```
c.contains(pat) //// c의 string에 pat가 포함되는지여부
```

  answer = Math.pow(sum,2)????????????


        return Math.max(Integer.valueOf(strSum1), Integer.valueOf(strSum2));


```Java
유용한 메소드들
import java.util.*;

Array
길이 고정

List
add, get, size, contains, remove
arrayList로도 씀

LinkedList
LinkedList list = new LinkedList();
LinkedList num2 = new LinkedList<>();
addFirst, addLast, add
removeFirst,removeLast, remove, clear
size, hasNext
contains

Set
hashSet(순서필요x),TreeSet(정렬된 값)
add, contains, equals, isEmpty, size
Obkect [] toArray()

Stack
Stack Stack_name = new Stack<>();

Queue
Queue< E > q = new LinkedList< E >();
offer(삽입)
poll(꺼냄),peek(보기만)
size, isEmpty

Dequeue
Deque< E > dq = new ArrayDeque< E >();
queue랑 동일 + pollFirst, pollLast, get

Map
HashMap<String, String> map = new HashMap<String, String>();
put, get, containsKet, remove, size

for( 객체 )
for (type var: iterate) {
body-of-loop
}

```


0. 라이브러리
import java.util.*;
import java.io.*;

1. 변수 선언
String[] arr1 = new String[5];
int[] arr2 = {1, 2, 3};

int N = 3;
int[] arr3 = new int[N];

2. Arrays
int arr[] = {10, 8, 11, 2, 3, 0};

// 1. 오름차순 {0, 2, 3, 8, 10, 11}
Arrays.sort(arr1);

// 2. 내림차순 {11, 10, 8, 3, 2, 0}
Arrays.sort(arr1, Collections.reverseOrder());

// 3. 일부만 정렬 {2, 8, 11, 10, 3, 0} (0~4만 정렬)
Arrays.sort(arr1, 0, 4)

// 4. 오름차순 정렬하면 binary search로 특정 값을 찾을 수 있다.
Arrays.binarySearch(arr1, 2);

// 5. 배열을 어레이리스트로 변환할 떼!
List list = Arrays.asList(arr1);

// 6. 배열의 특정 범위 자르기
int tmp[] = Arrays.copyOfRange(arr1, 0, 3);

3. length / length() / size()
length: 배열의 길이 (arr.length)
length(): String related object (str.length())
size(): Collections object (list.size())
// 1. length
int[] arr = new arr[3];
System.out.println(arr.length);

// 2. length()
String str = "java";
System.out.println(str.length());

// 3. size()
ArrayList<Integer> list = new ArrayList<>();
System.out.println(list.size());

4. String
String str = "hello world";

// 1. 자르기
str.split(" ");
str.substring(0, 5);
for(int i = 0; i < str.length(); i++) str.charAt(i);

// 1-1. 문자열을 배열로 만들고 싶을 때
String str = "12345";
String[] Arr = str.split("");

// 대소문자 변경
str = str.toUpperCase();		// HELLO WORLD
str = str.toLowerCase();		// hello world

// 한번 쓴 문자열은 변경 불가. substring 이용해서 새로운 변수로 선언해야함
String name="starfucks";
String newname=name.substring(0,4)+'b'+name.substring(5);	// starbucks


5. HashMap
// 1. 선언
HashMap<String, Integer> hm = new HashMap<>();

// 2. key-value 넣기
hm.put("java", 0);

// 3. 키로 값 가져오기
hm.get("java");

// 4. containsKey()로 존재유무 확인
if (!hm.containsKey("java")) hm.put("java", 1);

// 5. 특정 키가 없으면 값 설정, 있으면 기존 값 가져오는 함수
hm.put("java", hm.getOrDefault("java", 3);	

// 6. keySet() 함수로 맵 순회
for(String key : hm.KeySet()) {				
	hm.get(key);
}

6. ArrayList
// 1. 선언
ArrayList<String> list = new ArrayList<>();

// 2. 삽입
list.add("java");			// {"java"}
list.add(0, "ryu");			// {"ryu", "java"} (0번째 인덱스에 삽입)

// 3. 수정
list.set(1, "c++");			// {"ryu", "c++"}

// 4. 삭제
list.remove(1);				// {"ryu"}

// 5. 값 존재 유무 확인
list.contains("java");		// false
list.indexOf("ryu");		// 0 존재하면 인덱스 리턴

// 6. iterator 사용
Iterator it = list.iterator();

// 6-1. 인덱스 오름차순 순회
while (it.hasNext()) {
	...
}

// 6-2. 인덱스 내림차순 순회
while (it.hasPrevious()) {
	...
}

// 7. 중복없이 값을 넣고 싶을 때
if (list.indexOf(value) < 0) {	// 없으면 -1을 리턴하기 때문에
	list.put(value);
}

// 8. 리스트 값 하나씩 가져올 때 (int 일 경우)
for(int i = 0; i < list.size(); i++) {
	list.get(i).intValue();
}

7. Queue
// 1. 선언
Queue<Integer> q = new LinkedList<>();		// linked list로 선언해야함

// 2. 삽입
q.add(10);			// {10}
q.offer(2);			// {10, 2}

// 3. 프론트값 반환
q.peek();			// 10

// 4. 삭제
q.remove();
q.poll();

// 5. 초기화
q.clear();

// 6. 비었는지
q.isEmpty();

// 7. pair 같은 경우는 그냥 구현해서 사용
static class Node{
        int y;
        int x;
        int dist;
        
        Node(int y,int x,int dist){
            this.y=y;
            this.x=x;
            this.dist=dist;
       }
   }

Queue<Node> queue=new LinkedList<>();
queue.add(new Node(1,2,3));
Node node= queue.poll();

8. 우선순위 큐
// 1. 선언
PriorityQueue<Integer> pq = PriorityQueue<Integer>();	// 최소힙
PriorityQeueu<Integer> pq=PriorityQueue<Integer>(Collections.reverseOrder());	// 최대힙

// 2. 삽입
pq.add(3);

// 3. 삭제
pq.remove();

// 4. root 값 추출
pq.peek();

// 5. pair 사용 시 
import java.io.IOException;
import java.util.PriorityQueue;

public class PQ {

    static class Node{
        int y;
        int x;

        Node(int y,int x){
            this.y=y;
            this.x=x;
        }
		
        // 비교 함수 만들어야함!!
        public int compareTo(Node p) {
            if(this.y < p.x) {
                return -1; // 오름차순
            }
            else if(this.y == p.y) {
                if(this.x < p.x) {
                    return -1;
                }
            }
            return 1;
        }
    }

    public static void main(String[] args) throws IOException{

        PriorityQueue<Node> pq1=new PriorityQueue<>(Node::compareTo);
        pq1.add(new Node(1,2));
        pq1.add(new Node(1,1));
        pq1.add(new Node(2,3));
        pq1.add(new Node(2,1));

        while(!pq1.isEmpty()){
            Node node=pq1.peek();
            System.out.println(node.y+" "+node.x);
            pq1.remove();
        }
    }
}

8. Math 라이브러리
// 1. 최대 최소
Math.max(10, 2);
Math.min(10, 2);

// 2. 절대값
Math.abs();

// 3. 올림 내림 반올림
Math.ceil(-3.2);		// -3
Math.floor(-3.2);		// -4
Math.round(-3.26);		// -3	첫째자리에서 반올림

// 3-1. 소수 둘째, 셋째 자리에서 반올림 하고 싶다면
double a = 1.23456;
String b = String.format("%.1f", a);	// .1f는 둘째자리에서 반올림

// 4. 제곱 제곱근
Math.pow(2, 2);		// 2^2 = 4
Math.sqrt(4);		// 2