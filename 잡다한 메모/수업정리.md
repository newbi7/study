# SQL
```
Transaction
- ACID
1. Atomicity(원자성)  
"all or nothing"  
모든 연산이 완전하게 적용되거나 아무것도 적용되지 않음을 보장하는 특성이다.  
ex) 은행에서 A가 B에게 송금을 하는 과정에서 오류가 발생하였을때 원자성이 보장되어 송금 자체가 취소된다면 혼란을 방지할 수 있다.
2. Consistancy(일관성)  
일관성은 데이터베이스의 트랜잭션이 제약조건, cascades, triggers를 포함한 정의된 모든 조건에 맞게 데이터의 값이 변경됨을 의미한다. 프로그래머가 의도한 연산들에 대해 사전에 정의한 조건과 맞지 않는 데이터의 변경으로 인해 오류가 발생하지 않음을 보장해주는 것이다. 일관성을 보장해주지 못해 데이터를 제약조건에 맞지 않는 데이터가 입력된다면 외래키가 기본키를 참조하는 과정에서 참조 오류가 생길 수도 있고, 제한된 조건을 넘는 데이터를 의도적으로 입력하여 메모리를 덮어쓰는 버퍼 오버플로우 공격에 취약하는 등 오류와 공격에 취약해질 것이다.  
ex) 데이터 베이스에 CUD 연산을 진행하였을 때 스키마와 제약조건과 같이 사전에 설정한 룰에 맞지 않는 데이터가 들어가는 것을 방지해줄 수 있다.
3. Isolation(독립성)  
"동기화 개념"  
트랜잭션의 독립성은 DBMS에서 데이터의 무결성을 결정하는 특성이다. DBMS에서 다수의 유저들이 같은 시간에 같은 데이터에 접근하였을 때 수행중인 트랜잭션이 완료될 때 까지 다른 트랜잭션의 요청을 막음으로써 업데이트가 누락되는 등, 데이터가 꼬이는 것을 방지해줄 수 있는 것이다. 이 독립성이 없다면 복수의 사용자에 의해 dirty reads이나 lost updates이 발생할 것이다. 독립성은 Isolation Level으로 설정될 수 있는데, 레벨이 높다면 이러한 동시 작업에 대한 독립성이 높아지지만 시스템 자원이 많이 필요할 것이다. 반대로 레벨이 낮다면 독립성이 낮아지지만 시스템 자원이 반대로 적게 필요할 것이다.
4. Durablity(영속성)  
"데이터에 저장"  
지속성은 커밋된 연산이 영구적으로 지속됨을 보장하는 속성이다. 즉, 시스템 문제 등으로 인해 오류가 발생하더라도 구행된 트랜잭션이 영원히 반영되어야 한다는 것이다. 지속성은 로그를 이용하여 구현되는데, 커밋의 성능을 위해 지속성이 일부분 포기 되는 방식도 존재한다.



DTO는 계층(Layer)간 데이터 이동을 위해 사용되는 객체  
VO는 값을 갖는 순수한 도메인  
Entity는 이를 DB 테이블과 매핑하는 객체  
DTO - Layer간의 데이터 전송용 객체, 가변 혹은 불변, getter() / setter()메소드에 대한 로직만 포함한다.
vo - 값을 표현하는 객체, 불변, setter() 메소드 이외의 메소드를 가진다.
Entity - DB 테이블에 대해 매핑하는 객체, 가변 혹은 불변, 로직을 포함할 수 있다.
```
## JAVA
```java

1. MVC 패턴 구조
모델(Model), 뷰(View), 컨트롤러(Controller) 세 개의 컴포넌트로 이루어졌습니다.
1.1. 모델(Model)
DATA, 정보들의 가공을 책임지는 컴포넌트를 말합니다.
모델(Model)은 어플리케이션의 정보, 데이터를 나타냅니다. 데이타베이스, 처음의 정의하는 상수, 초기화 값, 변수 등을 뜻합니다. 비즈니스 로직을 처리한 후 모델의 변경사항을 컨트롤러와 뷰에 전달합니다.
// 모델의 규칙
- 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 합니다.
- 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 합니다.
- 변경이 일어나면, 변경 통지에 대한 처리 방법을 구현해야만 합니다.
Domain Model : Business logic처리에서 사용하는 데이터
Service(model) : 조직처리를 담당하는 componect

1.2. 뷰(View)
사용자에게 보여지는 부분, 즉 유저 인터페이스(User interface)를 의미합니다.
MVC 패턴은 여러 개의 뷰(View)가 존재할 수 있으며, 모델에게 질의하여 데이터를 전달받습니다. 뷰는 받은 데이터를 화면에 표시해주는 역할을 가지고 있습니다. 모델에게 전달받은 데이터를 별도로 저장하지 않아야 합니다. 사용자가 화면에 표시된 내용을 변경하게 되면 모델에게 전달하여 모델을 변경해야 합니다.
// 뷰의 규칙
- 모델이 가지고 있는 정보를 따로 저장해서는 안됩니다.
- 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 됩니다.
- 변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 합니다.

1.3. 컨트롤러(Controller)
모델(Model)과 뷰(View) 사이를 이어주는 브릿지(Bridge) 역할을 의미합니다.
모델이나 뷰는 서로의 존재를 모르고 있습니다. 변경 사항을 외부로 알리고 수신하는 방법만 있습니다. 컨트롤러(Controller)는 이를 중재하기 위해 모델과 뷰에 대해 알고 있어야 합니다. 모델이나 뷰로부터 변경 내용을 통지 받으면 이를 각 구성 요소에게 통지해야 합니다. 사용자가 어플리케이션을 조작하여 발생하는 변경 이벤트들을 처리하는 역할을 수행합니다.
// 컨트롤러의 규칙
- 모델이나 뷰에 대해서 알고 있어야 합니다.
- 모델이나 뷰의 변경을 모니터링 해야 합니다.


2. MVC 패턴 왜 사용할까?
'유지보수의 편리성', 'loosely coupled'(<->'tightly coupled')
유지보수가 발생하기 시작하면 각 기능간의 결합도(coupling)가 높아지는 경우가 발생합니다. 
결합도가 높아진 시스템은 유지보수 작업 시 다른 비즈니스 로직에 영향을 미치게 되므로 사소한 코드의 변경이 의도치 않은 버그를 유발할 수 있습니다.
이런 문제점을 해결하기 위해 UI 시스템의 핵심 컴포넌트를 모델, 뷰, 컨트롤러로 나누고 각 컴포넌트가 자신의 수행 결과를 다른 컴포넌트에게 전달하는 프로그래밍 방식을 만들었습니다. 
MVC 패턴을 가진 시스템의 각 컴포넌트는 자신이 맡은 역할만 수행한 후 다른 컴포넌트로 결과만 넘겨주면 되기 때문에 시스템 결합도를 낮출 수 있습니다.
유지보수 시에도 특정 컴포넌트만 수정하면 되기 때문에 보다 쉽게 시스템 변경이 가능합니다. 

3. MVC 패턴의 한계
복잡한 대규모 프로그램의 경우 다수의 뷰와 모델이 컨트롤러를 통해 연결되기 때문에 컨트롤러가 불필요하게 커지는 현상이 발생합니다. 복잡한 화면을 구성하는 경우에도 동일한 현상이 발생하는데 이를 'Massive-View-Controller' 라고 합니다.
```