# 지난 수업 정리
### 변수 (let, const, vol) -> hoisting

# Literal(리터럴)
``` Javascript
사람이 이해할 수 있는 기호, 문자를 이용해서 Value를 생성하는 표기법(notection)   
3 -> 정수 literal
3.1415 -> 실수 literal
" "    -> 문자열 literal
' '    -> 문자열 literal (자바스크립트에서 주로 쓰임)
` `    -> 문자열 literal
true, false -> boolean literal
null literal
undefined literal

Java -> 객체를 만드려면 new 생성자

Javascript -> 객체 literal {}
ex)
tmp = { 
    myName: '홍길동',
    myAddress : '서울'
}

Javascript 는 함수 literal -> function 이름(__) {}
ex)
var tmp1 = function myFunc() {
    console.log("깔깔깔!");
}
Javascript 가장 중요한 자료구조 -> "array" (배열)
[1, 2, 3]
```

# Statement (문장)
문장을 마칠때 ";"를 Javascript는 쓰지 않지만(optional, 사실 쓰는게 좋다) Java는 필수다.

# JavaScript Data Type
```java
// Java 
primitivedata type
int
double
char
short
byte
long
float
boolean
referencedata type
```
```javascript
// javascript
primitive data type
1. number(숫자) -> 정수와 실수의 구분이 없다.
2. Boolean(불리언) -> true, false
3. String(문자열) -> (``, '', "") 
4. null -> null
5. undefined -> undefined
6. Symbol 타입 -> Symbol은 고유하고 변경할 수 없는 식별자를 생성하며 한 번 생성하면 복사할 수 없다. Symbol의 사용 목적은 객체의 고유한 프로퍼티 키를 만들기 위해 사용된다.

preference data type
객체들 -> {}, 함수. []
```
변수도 type이 있나요?   
Java는 변수에 type이 있어요 -> 강 type언어   
Javascript는 변수에 type을 지정하지 않아요(var, let , const) -> 약 type언어 

Type Inference(동적타이핑 = 타입추론)   
타입 추론이란 TypeScript에서 명시적인 타입 표기가 없을 때 타입 정보를 제공하기 위해 사용되는 것이다. 자동으로 타입을 결정해주는 것이라고 보면 된다.

primitive type
-> 6개 -> 기본형 -> immutable특성(불변) -> 확보된 메모리 공간에 실제값이 저장
reference type
->mutable특성 (가변) -> 확보된 메모리에 실제값의 메모리 주소가 저장

# 객체
Java -> 객체(object) -> Distance
Javascript에서 객체를 생성하는 방법은 다양하다.
1. 객체 literal
{} -> empty objec(빈객체)
{
property, -> key : value "property"
property,
property
}

# function (함수)
vs java에서 가장 중요한 개념 = class   
Javascript의 class와 method - ES6에서 class 도입되었다.   
일련의 과정을 Statement로 작성해서 code block ({~})을 이용해서 하나의 단위로 묶어놓은것 -> java의 method와 비슷하다.
```
function myfunc(x,y) -> 함수이름, 식별자(identifier)   
x, y -> 매개변수(지역변수) parameter   
myfunc(10,20)   
10,20 -> 인자, 인수(argument)   
"코드의 유지보수성" 때문에 사용한다.
```
```javascript
함수 literal
let aa = function /* myfunc */ (x, y){  // 함수이름을 뺀다.
    return x+y;  // 함수 내부 (여기)에서만 myfunc를 사용할 수 있다. 
}
myfunc(10, 20) x    
aa(10, 20) o
```
### 함수를 정의하는 방법
```javascript
1. 함수 선언문 -> 함수를 변수에 저장하지 않고 독립적으로 존재한다.
named function -> 이름이 반드시 있어야한다.
ex) function myFunc(a, b) { return a + b; }
2. 함수 표현식 -> 
ex) let aa = function() {}
3. 생성자 함수 (Function) 을 이용해서 함수를 생성 (코드에서 사용 x)
let bb = new Function('x', 'y', 'return x + y');
4. 화살표함수(Arrow Function)
let cc = (x, y) => {return x + y};
```

### 함수 선언문, 함수 표현식
이렇게 만들어진 함수를 호출(call, invoke) 해 보는데
인자의 개수를 맞추지 않아도 호출됩니다.
arguments 내장배열에 인자가 모두 저장됩니다.

### JavaScript를 특이한 함수 호출 방식 (IIFE)
```
Immediately Invoked Function Expression (즉시 실행되는 함수 표현식) 의 약자로 정의
(function () { console.log('Hello World') })(); // Hello World
즉시 실행 함수는 언제 사용하나요?
즉시 실행 함수는 함수를 즉시 평가하여 값으로써 활용하는것 의미가 있기 때문에, 꼬집어 그 용도를 정의하긴 어렵습니다만 보편적으로는 전역 스코프를 오염시키지 않기 위해 사용하는 경우가 많습니다
 즉시 실행 함수는 익명(기명도 가능하긴 하지만)함수를 () 로 감싸야만 할까요?
function() {} 과 같이 작성되면, 자바스크립트 코드를 해석하는 파서는
이것을 함수 선언문(statement) 으로 인지합니다.
문은 자바스크립트 해석기에게 명령을 지시하고 사라지는 것이기 때문에 "값"으로 남지 않습니다
따라서, () 와 같이 괄호로 묶어주어
이것은 "함수 선언문이 아닌 "함수 표현식" 이라는 것을
명시적으로 나타내야 합니다
익명함수를 값으로 나타내기 위해서는 (=함수 표현식으로 만들기 위해서는) () 로 묶어주는 것 외에도, 연산자를 앞에 붙여줄 경우에는 모두 즉시 실행 됩니다
```
### 중첩함수
```
자바스크립트는 함수 안쪽에 또 다른 함수를 선언하는 중첩(nested) 함수가 가능하다. 이는 자바스크립트가 함수(function)를 변수와 같이 값(value)처럼 다루기 때문인데 일례로 자바스크립트에서는 같은 이름의 변수와 함수를 선언하는 것이 불가능하다.
1. 클린 코드적 관점
// 유저가 무직자인지 확인한다.
if(user.job == null) {}
if(user.isUnemployed()) {}
두 개의 코드 예제는 같은 행동을 나타낸다.
즉, 단위 로직을 함수로 만드는 행위는 클린 코드에 도움이 되고, 이러한 관점에서 볼 때 자바스크립트의 중첩 함수는 좀 더 강력한 도구가 된다.
function foo(){
  function bar() {
        console.log('Hello');
  }
    bar(); // Hello가 출력된다.
}
bar(); // 에러발생!, bar is not defined
중첩함수는 선언된 함수 내부가 아니면 호출하는 것이 불가능하다.
bar함수를 foo함수 내부에 위치시킨다는 것은 bar함수는 foo함수 내부에서만 사용될 것임을 명시적으로 나타낸다. 이는 코드를 읽어나가는데 분명한 도움이 된다.
접근제어자가 존재하는 Java와 같은 언어에서도 한 Class내부에 여러 개의 public 메서드가 존재하고 각 public 메서드가 사용하는 private 메서드가 존재한다면, 어떤 private 메서드가 어떤 public 메서드와 어우러지는지 확인하기 어려운 경우가 있다.
자바스크립트는 접근제어자가 없더라도 공개적(public)으로 사용되는 함수와 이 함수를 도와주는 지역적 헬퍼(helper) 함수를 중첩 함수로 둠으로써 좀 더 명확한 구분이 가능하다.

2. 성능적 관점
자바스크립트의 엔진이 함수가 실행될 때, 그 함수 내부에 존재하는 지역적인(local) 변수들이 존재한다면 그 변수들은 함수가 실행될 때만 존재된다. 함수가 종료되면 지역적인(local) 값들과 객체들은 사라지게 된다.
중첩된 함수가 변수와 같이 값(value)처럼 다뤄진다는 사실을 다시 한번 상기해보자.
function foo(a, b) {
    function bar() {
        return a + b;
    }
    return bar();
}
foo(1, 2);
foo 함수가 실행될때 bar함수 객체가 생성되고 bar함수가 실행된다. 그리고 foo 함수가 종료될 때 지역적인 함수 bar 객체는 파괴된다.
만약 foo함수가 100번 실행된다면, bar함수 객체는 100번 생성되었다가 100번 파괴된다.
bar함수를 중첩시키지 않고 외부에 그대로 노출시킨다면 어떨까?
function foo(a, b) {
    return bar(a, b);
}
function bar(a, b) {
    return a + b;
}
foo(1, 2);

3. 기능적 관점 - 클로저(closure)
클로저는 자바스크립트의 특징을 활용한 일종의 테크닉이라고 볼 수 있다.
앞서서 얘기했던 대로, 자바스크립트 함수의 지역적으로 선언된 값들은 함수가 종료되면 사라진다. 하지만 사라지지 않게 하는 방법이 있다.
return을 활용하여서 내부의 값들 중 외부로 노출시키고자 하는 값들을 바깥세상에 노출한다. return문이 외부 스코프와 함수 내부를 이어주는 일종의 '통로'가 되는 것이다.
이러한 기법을 '클로저'라고 한다.
function makeFunc() {
  var name = "siyoon";
  function displayName() {
    alert(name);
  }
  return displayName;
}
위의 예제 코드가 클로저 기법을 활용한 것이다. displayName이라는 중첩 함수가 존재하지만 return문을 통해서 중첩함수가 외부에 노출되었다. 이제 makeFunc함수를 호출할 수 있다면 중첩 함수인 displayName함수 또한 호출이 가능하다.
```

### callback 함수
자바스크립트에서 많이 활용된다.

Higher - order function
callback