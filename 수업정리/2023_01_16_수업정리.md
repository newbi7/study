Scope - 변수가 선언된 위치에 따라 자신이 유효한 범위   
Javascript => function -level scope 가 기본

다른언어(c, Java) => block-level scope가 기본

함수의 상위 scope를 결정할때
1. 함수를 어디에서 호출했는지에 따라 결정한다.
dynamic scope
2. 함수를 어디에서 정의했는지에 따라 결정한다. 
static scope(lexical scope)
### 렉시컬 스코프
```Javascript
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
위 코드의 실행결과는, bar 함수의 상위 스코프가 무엇인지에 따라 결정이 됩니다.
상위 스코프를 결정하는 방법은 두 가지 패턴이 존재합니다.
첫 번째. 함수를 어디서 '호출' 하는가
두 번째. 함수를 어디서 '선언' 하는가
첫 번째 방식을 동적 스코프(Dynamic scope)라 하고, 두 번째 방식을 렉시컬 스코프(Lexical scope) 또는 정적 스코프(Static scope)라고 합니다.
자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프 즉 함수를 어디서 '선언' 하였는지에 따라 결정됩니다.
예시 코드에서 bar 함수는 전역에서 선언되었습니다.
자바스크립트는 함수를 어디서 '선언'하는지에 따라 상위스코프가 결정되는 렉시컬 스코프 이므로, bar 함수가 선언된 전역(글로벌)이 상위스코프가 됩니다.
따라서, 예시 코드에서 foo(), bar() 모두 전역 변수 x인 1을 출력합니다.
```
### 전역 scope
 -> 여기서 선언된 변수를 전역변수라고 해요(global variable)   

### Javascript는 전역객체
1. browser 환경에서 실행
전역객체의 이름 - window
2. Node.js 환경에서 실행
전역객체의 이름 - global

전역객체 통일 - globalThis(ES11) 했지만 ES11버젼은 너무 나중버젼이라 못쓴다.

# 전역객체
전역객체 - 전역변수 많을수록 무거워서 힘들어진다. (잘 안 쓰는게 나음)   
전역변수의 문제점
1. 가독성이 안 좋다. 의도치 않은 문제 발생
2. 생명주기가 길어서 resource를 오랜기간 소모
3. scope chain의 최상위에 위치

전역변수 대신
1. IIFE (즉시 실행 함수)
2. Module을 이용 (module scope)
```Javascript
Javascript  
Internal slot (내부 슬롯) -> 변수 =>  [[]]
Intrnal method (내부 메소드) -> 함수 => [[]]
이런 내부 슬롯과 내부 method 를 개발자가 직접 사용할 수 없어요
-> Javascript Engine에 의해서 사용된다.
-> 하지만 필요에 의해 간접적으로 이 슬롯과 메소드를 사용 할 수있어요
[[Prototype]] -> 내부 slot(변수) -> property
직접적인 사용은 안되고 간접적인 사용을 허용 -> __proto__

property -> 객체의 구성요소
key : value의 쌍으로 구성
attribute를 가지고 있다.
4개가 문제 -> 이 4개가 모두 내부 slot으로 구성되어 있다.
[[Value]] : property의 value
[[Writable]] : true, false
[[Enumerable]] : true, false
[[Configurable]] : true, false

writable – true이면 값을 수정할 수 있습니다. 그렇지 않다면 읽기만 가능합니다.
enumerable – true이면 반복문을 사용해 나열할 수 있습니다. 그렇지 않다면 반복문을 사용해 나열할 수 없습니다.
configurable – true이면 프로퍼티 삭제나 플래그 수정이 가능합니다. 그렇지 않다면 프로퍼티 삭제와 플래그 수정이 불가능합니다.

Object 생성자 함수 -> Javascript의 모든 함수를 최상위에 위치
Javascript 함수 -> 객체 -> property를 가져요
Object.getOwnProperty Descriptor() = property

내부 슬롯
내부 메소드
[[]]
기억해야 되는 대표적인 Prototype -> JavaScript의 모든 객체가 다 가지고 있는 내부 slot
```
### 생성자 함수
```Javascript
★ built-in 생성자 함수
Object, String, Number, Boolean
Function, Array, Date, ....

★ user define 생성자 함수
Const obj = {} -> literal로 객체 생성
객체를 생성할때 생성자 함수를 이용할 수 있다.
```
### 객체를 여러개 만드려면 어떻게 하는게 좋은가
```
"동일한 property를 가지는 객체를 여러개"
생성자 함수를 정의한 후 "new" 를 이용해서 객체를 생성한다.
그러면 생성자 함수는 마치 Java의 class 처럼 이용할 수 있어요
ES6(ECMA 2015)에 class 개념과 keyword가 도입 되지만 실제 동작은 생성자함수로 한다.
```
### this 
1. 일반 함수내에서 this -> 전역객체 (window)
2. 메소드형태로 실행된 함수내에서 this -> method를 호출한 instance(Java)
3. 생성자 함수 내에서 this -> 그 생성자 함수로 만들어진 객체를 지칭

### 함수는 형태에 의해 그 종류가 결정되지 않아요
```
어떻게 사용되느냐에 따라 그 종류가 결정된다.
생성자 함수, 일반 함수 -> new
생성자함수는 내부에 일반적으로 return이 없다.
묵시적으로 만들어진 객체가 return되기 때문이다.
일반함수는 내부에 일반적으로 return이 있다. return이 없으면 undefined가 리턴된다.
함수는 reference type -> Object(객체) -> property의 집합
따라서 함수에도 property를 등록할 수 있다.
특별히 함수객체는 내부슬롯 2개, 내부 method 2개가 기본적으로 있다. (항상 2개를 가지는건 아니다.) 
내부 method - [[Call]], [[Construct]]
[[Call]] -> 모든 함수 객체가 다 가지고 있어요
[[Constuct]] -> 객체를 만들 수 있는 놈들만 가지고 있다.

```
### First - class Object (일급객체)
1. 익명으로 literal로 생성 가능한 객체
2. Value로 판단이 가능 -> 변수나 자료구조에 저장 가능
3. 함수를 이용할때 인자로 넘길 수 있는 객체
4. 함수의 리턴값으로 이용할 수 있는 객체 -> ★클로져
            (function)
Javascript의 함수는 일급객체 (일급함수)
함수의 형태(property) 확인하기 위해 console.log(##) 사용했었는데 내부를 조금더 들여다 보기 위해 console.dir(##)을 사용할 예정이다.