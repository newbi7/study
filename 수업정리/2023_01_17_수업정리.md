# Javascript
### 함수 -> Reference Type (Object)
property를 가지고 있다. console.dir()

함수객체는 일반객체가 가지지 않는 특수한 property가 자동으로 붙는다.
1. arguments : 유사배열객체(현재는 Rest parameter가 더 많이 쓰인다.)
2. caller : A-caller, b-callee 구현을 할때는 상당히 유용하지만 비표준이다.
3. length : parameter가 몇개인가요?
4. name : sum
5. prototype : 함수(객체)를 이용해서 객체를 생성(new)할 수 있다. 
이렇게 만들어진 객체는 [[Prototype]]을 가지고 있다. 이 [[Prototype]] 내장슬롯의 값을 가지고 있는 property가 바로 prototype이다. constructor 만 가지고 있는 property이다.

Javascript
```javascript
- 함수기반언어
- prototype 기반언어 (상속개념)
- 객체지향개념 (객체기반언어)
-> 멀티 패러다임 언어
ES6에서 class가 도입되지만 객체지향의 class와는 다르게 실제로는 생성자 함수로 동작한다.

생성자 함수를 이용한 객체 생성의 문제
        Circle 생성자 함수
      new                        new 
    Circle1                    Circle2
radius     2            radius      5
getArea  function(){}   getArea  function(){}
->> getArea가 계속 생성되어서 메모리 낭비가 심하다.
-> prototype으로 해결하자
// Circle 생성자 함수
// prototype

// Circle의 prototype객체
// getArea function
getArea -> 따로 생성되어서 자동으로 적용
상속받는 상위 prototype 객체에 대한 reference
```
모든 객체는 하나의 (상위)Prototype객체를 가진다.
이런 (상위) prototype 객체는 생성자 함수와 연관되어 있다.

Scope Chain (변수찾을떄 사용) vs Prototype Chain (프로토 찾을떄 사용)

Prototype 객체는 생성자 함수를 정의하고 실행하면 생성자 함수 객체 생성
+ 생성자 함수의 Prototype 객체 생성
생성자 함수가 아닌 "non-constructor" 함수는 prototype이 없다.
1. method
2. arrow-function

Strict mode (엄격)
-> 'Use Strict';
-> 1. 묵시적 전역이 안된다.
-> 2. property의 삭제가 안된다. (delete있지만 하면 안됨)
-> 3. Strict mode 에서는 일반 함수에서 this 사용시-> Window(전역객체)가 아니라 undefined

Javascript (ECMAScript 2015)
-> 언어의 기본 특성, 성질에 대해 알아보고 있다. -> 몰라도 Front-End web application 을 만들수 있다.
-> application 구현은 "Library Framework를 이용 (JQuerry, Vue.js)
 
## Closure
```javascript
자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.
클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.
스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정된다. 이를 렉시컬 스코핑(Lexical scoping)라 한다. 
자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부른다. 
클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다.
실행 컨텍스트의 관점에 설명하면, 내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 활성 객체(Activation object)(변수, 함수 선언 등의 정보를 가지고 있다)는 내부함수에 의해 참조되는 한 유효하여 내부함수가 스코프 체인을 통해 참조할 수 있는 것을 의미한다.
즉 외부함수가 이미 반환되었어도 외부함수 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지된다. 이때 내부함수가 외부함수에 있는 변수의 복사본이 아니라 실제 변수에 접근한다는 것에 주의하여야 한다.
#2. 클로저의 활용
클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있지만 클로저가 유용하게 사용되는 상황에 대해 살펴보자.
#2.1 상태 유지
클로저가 가장 유용하게 사용되는 상황은 현재 상태를 기억하고 변경된 최신 상태를 유지하는 것이다. 클로저는 현재 상태를 기억하고 이 상태가 변경되어도 최신 상태를 유지해야 하는 상황에 매우 유용하다. 클로저라는 기능이 없다면 상태를 유지하기 위해 전역 변수를 사용할 수 밖에 없다. 
#2.2 전역 변수의 사용 억제
변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 함수형 프로그래밍에서 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.
#2.3 정보의 은닉
```
우리의 Javascript code는 4개의 type으로 분류
```
1. 전역코드 : global 영역 통제하는 코드
2. 함수코드 : 함수 내부에 존재하는 소스코드. 중첩함수 내부까지는 포함하지 않는다.
3. eval 코드 : eval()이라는 built-in 함수가 있다. 인자로 code를 넣을 수 있다. 
4. module 코드 : module scope 안에 있는 소스코드
이렇게 코드를 나누는 이유는 특정 type 의 코드가 실행되면 execution context가 생성하고 동작하는 방식이 달라지기 때문이다. (실행 컨텍스트)
- 전역코드 -> 전역변수를 관리하기 위해 최상위 scope인 전역 scope가 생성된다.
var keyworld로 변수를 선언한다.   
window객체에 property로 등록
전역에서 선언한 함수도 window객체에 property로 등록   
=> 작성을 하기 위해 전역 execution context가 생성된다.
- 함수코드
local scope 가 생성된다. 지역변수, 매개변수 scope chain도 만들어져야한다.
함수 execution context가 생성된다. 
execution context -> 소스코드를 실행하는데 필요한 환경을 제공하고 실행결과를 메모리에 관리한다.
식별자, scope 같은 것들은 execution context의 lexical Environment 코드 실행 순서는 execution context stack에서 관리한다.
```