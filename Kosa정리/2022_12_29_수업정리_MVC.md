# 오늘 배울 것
3. connection pool의 구성과 응용
4. MVC 패턴 (DAO포함)

# Connection Pool
POOl  
object pool  
Thread pool  
connection pool  
```
만드는 작업이 시간이 오래걸리기 때문에 pool을 미리 만들어서 대여개념으로 하는게 좋다.
서버가 DB에 연결하기 위한 Connecting 비용이 가장 큰 비율을 차지한다. 
이처럼 Connection을 생성하는 작업은 비용이 많이 드는 작업이다. 
이를 보완할 수 있는 방법이 바로 Connection Pool이다.
커넥션 풀은 데이터베이스와 연결된 커넥션을 미리 만들어 놓고 이를 pool로 관리하는 것이다. 필요할 때마다 커넥션 풀의 커넥션을 이용하고 반환하는 기법이다. Connection에 필요한 비용을 줄일 수 있고 DB에 빠르게 접속할 수 있다. 또한 커넥션 풀을 사용하면 커넥션 수를 제한할 수 있어서 과도한 접속으로 인한 서버 자원 고갈을 방지할 수 있으며 DB 접속 모듈을 공통화해 DB 서버의 환경이 바뀔 경우 유지보수를 쉽게 할 수 있다. 커넥션 풀의 크기는 어느 정도인 게 좋을까?
pool size = Tn x (Cm-1) + 1
Tn = 전체 Thread의 개수
Cm = 하나의 Task에서 동시에 필요한 Connection 수
```
설명하기 위해 JavaFX를 이용하는데 실제로 connection pool로 was와 같은 multi thread환경에서 사용한다.
connection pool -> 사용시 library 사용해야한다. 따라서 Apache에서 제공하는 DBCP라는 connection pool을 사용한다.  

## Apache에서 제공하는 DBCP 파일  
commons-dbcp  
commons-pool  
commons-logging
세개 파일 다운로드 받고 -> .jar 파일 필요하다.  
DBCP 파일 + mysql파일 활용해서 코드작성시작

# Layerd Architecture (계층구조)
```java
일반적인 소프트웨어를 구현할떄 가장 널리 사용되는 아키텍쳐(프로그램 구조)
N(정수)-tier Architecture
구성되는 계층의 숫자에 따라 N 계층 아키텍처 (N-tier Architecture) 라고도 한다. 
Layered Architecture 패턴에서 구성 레이어 숫자나 각 레이어의 유형을 명시하고 있지는 않지만, 일반적인 경우 아래와 같은 유형의 4개의 레이어로 구분한다.
```
각 kyer(계층)은 어떤 기준으로 나누나요  
1.역할  
2.concern(관심사(화면 표시, 비즈니스 로직 수행, DB 작업 등))
```Java
1. Presentation Layer
-> 표현계층 -> 사용자와 직접 대면하는 역할
사용자가 데이터를 전달하기 위해 화면에 정보를 표시하는 것을 주 관심사로 둔다. 
특정 계층의 구성요소는 해당 계층에 관련된 기능만 수행한다. 이런 특징은 높은 유지보수성과 쉬운 테스트라는 장점이 존재한다.
Presentation Layer 는 비즈니스 로직이 어떻게 수행되는지 알 필요가 없다. 대표적인 구성요소는 View와 Controller가 있다.

2. Business Layer
-> 조직처리
비즈니스 로직을 수행하는 것을 주 관심사로 둔다. 마찬가지로 화면에 데이터를 출력하는 방법이나 혹은 데이터를 어디서, 어떻게 가져오는지에 대한 내용은 알고있지 않다. 그저 Persistence Layer에서 데이터를 가져와 비즈니스 로직을 수행하고 그 결과를 Presentation Layer 로 전달하면 된다. 대표적인 구성요소는 Service와 Domain Model 등이 있다. 경우에 따라 Service와 Domain Model을 별개의 계층으로 나누거나, 아예 Domain Model을 Layered Architecture 와 별개의 것으로 분리하는 경우도 더러 있는 것 같다
중요한것은 Layered Architecture 의 사용 이유와 특징을 잘 이해하고 사용하는 것 이므로, 설득력 있는 구조라면 어떻게 설계해도 괜찮다고 생각한다.

    3. Persistence Layer
-> 데이터베이스 처리
어플리케이션의 영속성을 구현하기 위해, 데이터 출처와 그 데이터를 가져오고 다루는 것을 주 관심사로 둔다. 대표적인 구성요소는 Repository, DAO 등이 있다.

4. Database Layer
-> 실제 데이터베이스 처리
MySQL, MariaDB, PostgreSQL, MongoDB 등 데이터베이스가 위치한 계층을 의미한다.

- 수직적으로 구성된 격리된 레이어 (Layers of isolation)
Layered Architecture에서 각각의 나뉘어진 수평 계층은 수직적으로 배치된다.  이런 구조에서 특정 레이어는 바로 하위 레이어에만 연결된다.
Presenstation Layer 에서 직접 데이터베이스에 접속하여 데이터를 가져오게 되면, SQL에 대한 변경사항이 Presentation Layer에 직접 영향을 미친다. 즉, 과도한 의존성이 발생하게 된다. 이는 어플리케이션의 변경을 매우 어렵게 만든다.
Layered Architecture 에서 각 레이어는 격리되어 있다. 각 레이어가 다른 레이어와 독립적이므로 특정 레이어는 다른 레이어의 내부 동작을 모르게 된다. 즉 각 계층은 캡슐화되어 있고, 단일 책임을 갖는다. 따라서 특정 레이어는 다른 레이어에 영향을 주지 않고 변경될 수 있다.

Layered Architecture 시나리오
사용자가 특정 고객 정보를 요청한 상황을 가정하여, Layered Architecture 가 이 요청을 수행하는 시나리오를 정리해보자.
사용자가 보고있는 화면(Customer Screen, 흔히 말하는 View 라고 할 수 있을 것 같다)에서 사용자는 고객 정보를 요청한다.
이 요청은 그 요청을 처리할 수 있는 모듈이 무엇인지 알고있는 Customer Delegate (흔히 말하는 Controller 라고 할 수 있을 것 같다) 로 전달된다. Customer Delegate 는 해당 요청을 처리하기 위해 Business Layer 의 Customer Object 로 요청을 다시 전달한다.
Customer Object는 요청을 받고 비즈니스 로직을 수행하기 위한 데이터를 얻기 위해, Persistence Layer의 Customer dao 와 Order dao 에 요청을 보낸다.
Persistence Layer 의 DAO들은 요청을 수행하기 위해 Database Layer 에 접근하여 데이터를 가져온다.
이 요청은 다시 반대로 Persistence Layer → Business Layer → Presentation Layer 로 전달되고 최종적으로 사용자에게 전달된다.

싱크홀 안티패턴을 주의하자!
싱크홀 안티패턴이란 특정 레이어가 아무런 로직도 수행하지 않고 들어온 요청을 그대로 다시 하위 레이어로 내보내는 경우를 의미한다. 이런 흐름은 불필요한 리소스 낭비를 초래한다. 전체 흐름 중에서 약 20%가 싱크홀이라면 그럭저럭 나쁘지 않은 수준이라고 한다
```
# MVC(Model, View, Controller) Pattern
```Java
모델-뷰-컨트롤러(model–view–controller, MVC)는 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴이다. 어플리케이션을 세 개의 영역으로 분할하고 각 구성 요소에게 고유한 역할을 부여하는 개발 방식입니다. MVC 패턴을 도입하면 도메인(비즈니스 로직) 영역과 UI 영역이 분리되므로 서로 영향을 주지 않고 유지보수가 가능합니다. MVC 패턴의 구조를 살펴보면서 각 컴포넌트가 무슨 역할을 수행하는지 알아보도록 하겠습니다.

1. MVC 패턴 구조
모델(Model), 뷰(View), 컨트롤러(Controller) 세 개의 컴포넌트로 이루어졌습니다.
1.1. 모델(Model)
DATA, 정보들의 가공을 책임지는 컴포넌트를 말합니다.
모델(Model)은 어플리케이션의 정보, 데이터를 나타냅니다. 데이타베이스, 처음의 정의하는 상수, 초기화 값, 변수 등을 뜻합니다. 비즈니스 로직을 처리한 후 모델의 변경사항을 컨트롤러와 뷰에 전달합니다.
// 모델의 규칙
- 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 합니다.
- 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 합니다.
- 변경이 일어나면, 변경 통지에 대한 처리 방법을 구현해야만 합니다.
Domain Model : Business logic처리에서 사용하는 데이터
Service(model) : 조직처리를 담당하는 componect

1.2. 뷰(View)
사용자에게 보여지는 부분, 즉 유저 인터페이스(User interface)를 의미합니다.
MVC 패턴은 여러 개의 뷰(View)가 존재할 수 있으며, 모델에게 질의하여 데이터를 전달받습니다. 뷰는 받은 데이터를 화면에 표시해주는 역할을 가지고 있습니다. 모델에게 전달받은 데이터를 별도로 저장하지 않아야 합니다. 사용자가 화면에 표시된 내용을 변경하게 되면 모델에게 전달하여 모델을 변경해야 합니다.
// 뷰의 규칙
- 모델이 가지고 있는 정보를 따로 저장해서는 안됩니다.
- 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 됩니다.
- 변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 합니다.

1.3. 컨트롤러(Controller)
모델(Model)과 뷰(View) 사이를 이어주는 브릿지(Bridge) 역할을 의미합니다.
모델이나 뷰는 서로의 존재를 모르고 있습니다. 변경 사항을 외부로 알리고 수신하는 방법만 있습니다. 컨트롤러(Controller)는 이를 중재하기 위해 모델과 뷰에 대해 알고 있어야 합니다. 모델이나 뷰로부터 변경 내용을 통지 받으면 이를 각 구성 요소에게 통지해야 합니다. 사용자가 어플리케이션을 조작하여 발생하는 변경 이벤트들을 처리하는 역할을 수행합니다.
// 컨트롤러의 규칙
- 모델이나 뷰에 대해서 알고 있어야 합니다.
- 모델이나 뷰의 변경을 모니터링 해야 합니다.

2. MVC 패턴 왜 사용할까?
'유지보수의 편리성', 'loosely coupled'(<->'tightly coupled')
유지보수가 발생하기 시작하면 각 기능간의 결합도(coupling)가 높아지는 경우가 발생합니다. 
결합도가 높아진 시스템은 유지보수 작업 시 다른 비즈니스 로직에 영향을 미치게 되므로 사소한 코드의 변경이 의도치 않은 버그를 유발할 수 있습니다.
이런 문제점을 해결하기 위해 UI 시스템의 핵심 컴포넌트를 모델, 뷰, 컨트롤러로 나누고 각 컴포넌트가 자신의 수행 결과를 다른 컴포넌트에게 전달하는 프로그래밍 방식을 만들었습니다. 
MVC 패턴을 가진 시스템의 각 컴포넌트는 자신이 맡은 역할만 수행한 후 다른 컴포넌트로 결과만 넘겨주면 되기 때문에 시스템 결합도를 낮출 수 있습니다.
유지보수 시에도 특정 컴포넌트만 수정하면 되기 때문에 보다 쉽게 시스템 변경이 가능합니다. 

3. MVC 패턴의 한계
복잡한 대규모 프로그램의 경우 다수의 뷰와 모델이 컨트롤러를 통해 연결되기 때문에 컨트롤러가 불필요하게 커지는 현상이 발생합니다. 복잡한 화면을 구성하는 경우에도 동일한 현상이 발생하는데 이를 'Massive-View-Controller' 라고 합니다.

```
# DAO (Data Acess Object)
```Java
Data Access Object의 약자로, 데이터베이스의 데이터에 접근하기 위해 생성하는 객체이다.
데이터베이스에 접근하기 위한 로직과 비즈니스 로직을 분리하기 위해 사용한다.
간단하게, DB에 접속하여 데이터의 CRUD(생성, 읽기, 갱신, 삭제) 작업을 시행하는 클래스이다.
코드의 간결화 및 모듈화, 유지보수 등의 목적을 위해 별도의 DAO 클래스를 생성하여 사용하는 것이 좋다.
```